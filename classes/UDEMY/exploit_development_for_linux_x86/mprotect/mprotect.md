# Using mprotect() at runtime to turn a non-executable stack into an executable stack  
  
* `man 2 mprotect` tells us: int mprotect(void addr[.len], size_t len, int prot);  
#######################EAX########EBX######ECX###EDX 
  
* GDB is a dynamic debugger which means we can pause a program, and, for example, modify the content of the registers with values we want to use, and run the program again.  
* We want to see if we can use mprotect() syscall in a program that doesnt originally include it in order to turn the stack into an executable one, and therefore, bypass the NX protection.  
  
  
## Plan:  
  
1. launch GDB on the program.  
2. create a breakpoint and run the program.  
3. get the stack base address.  
4. get mprotect() address, go there and change the values stored in the ECX, EBX and EDX registers.  
6. run the program until the syscall has been done.  
7. check if the stack has become executable.
  
  
## Details:  
  
* Launch GDB on vulnerable, create a breakpoint, run the program  
```bash  
gdb vulnerable  
...  
gef➤ b _start  
gef➤ r  
```  
  
* Use `vmmap` to get the stack base address  
```bash  
gef➤ vmmap  
...  
0xfffdd000 0xffffe000 0x00000000 rw- [stack]  
```  
  
* Disas mprotect to get its base address  
```bash  
gef➤ disas mprotect  
...  
0xf7e8f0d0 <+0>: push ebx		# mprotect() base address
```  
  
* Change EIP value so when the next instruction is executed using `si` we land straight into mprotect.  
```bash  
gef➤ set $eip=0xf7e8f0d0  
gef➤ si		# this should land you directly inside mprotect() if you have setup EIP properly
```  
  
* At this point we are inside mprotect. Keep using `si` until reaching the calling point  
```bash  
0xf7e8f0e2 <mprotect+0012> call DWORD PTR gs:0x10  # you should see something like this
```  
> Depending on what you use to compile your program, what appears can be different, so if doesnt look exactly the same, no panic. Do you see the instruction 'call' ? Yes ? Then you should be good.
  
* The next instruction will run the syscall, this means all the parameters are already on the stack, in their respective registers, ready to be 'consumed' when the syscall executes. 
* We know the first param will go into EBX,  the second in ECX and the last into EDX.   
--> EBX will contain the stack base address (the area we wanna apply our changes to): 0xf7e8f0e2  
--> ECX will contain the size. 
--> EDX will contain the 'rights' value: 7 for `rwx`

* In order to find the size we wanna use, lets make few calculations using GDB:  
```bash  
gef➤ vmmap  
...  
0xfffdd000 0xffffe000 0x00000000 rw- [stack]  
gef➤ x/x 0xffffe000-0xfffdd000  
0x21000: Cannot access memory at address 0x21000  
```
> This means we need a size of at least 0x21000 in order to be sure to cover the whole stack.
* Let's setup the registers:
```bash
gef➤ set $ebx=0xfffdd000
gef➤ set $ecx=0x21000
gef➤ set $edx=0x7
gef➤ si
```
* Use `si` unti you reach the ret instruction point: `0xf7fc757c <__kernel_vsyscall+000c> ret`
> again this could be differently represented, but the point is to reach the `ret` instruction in order to make sure the syscall has been *(close to fully)* executed.

* Check the stack it should now be executable
```bash
gef➤ vmmap  
...
0xf7d75000 0xf7d98000 0x00000000 r-- /usr/lib32/libc.so.6  
0xf7d98000 0xf7f16000 0x00023000 r-x  /usr/lib32/libc.so.6  
0xf7f16000 0xf7f9b000 0x001a1000 r-- /usr/lib32/libc.so.6  
0xf7f9b000 0xf7f9d000 0x00226000 r-- /usr/lib32/libc.so.6  
0xf7f9d000 0xf7f9e000 0x00228000 rw- /usr/lib32/libc.so.6  
0xf7f9e000 0xf7fa8000 0x00000000 rw-  
0xf7fc1000 0xf7fc3000 0x00000000 rw-  
0xf7fc3000 0xf7fc7000 0x00000000 r-- [vvar]  
0xf7fc7000 0xf7fc9000 0x00000000 r-x  [vdso]  
0xf7fc9000 0xf7fca000 0x00000000 r-- /usr/lib32/ld-linux.so.2  
0xf7fca000 0xf7fed000 0x00001000 r-x  /usr/lib32/ld-linux.so.2  
0xf7fed000 0xf7ffb000 0x00024000 r-- /usr/lib32/ld-linux.so.2  
0xf7ffb000 0xf7ffd000 0x00032000 r-- /usr/lib32/ld-linux.so.2  
0xf7ffd000 0xf7ffe000 0x00034000 rw- /usr/lib32/ld-linux.so.2  
0xfffdd000 0xffffe000 0x00000000 rwx  [stack]
```


