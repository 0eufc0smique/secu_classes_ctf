### Using mprotect() at runtime to turn a non-executable stack into an executable stack

* `man 2 mprotect` tells us: int mprotect(void addr[.len], size_t len, int prot); 
                                     eax           ebx         ecx        edx
* GDB is a dynamic debugger which means we can pause a program, and, for example, modify the content of the registers with values we want to use, and run the program again.
* We want to see if we can use mprotect() syscall in a program that doesnt originally include it in order to turn the stack into an executable one, and therefore, bypass the NX protection.

### PLAN

1. launch GDB on the program
2. pause the program where needed, get the needed addresses
3. get mprotect() address, go there, use `si` until you reach the point where all the parameters values have been pushed onto the stack, change those values
4. run the program again and see if the stack is now executable

### Details

* Launch GDB on vulnerable, create a breakpoint, run the program
```bash
gdb vulnerable
...
gef➤  b _start
gef➤  r```

* Use `vmmap` to get the stack base address
```bash
gef➤  vmmap
...
0xfffdd000 0xffffe000 0x00000000 rw- [stack]```

* Disas mprotect to get its base address
```bash
gef➤  disas mprotect
...
0xf7e8f0d0 <+0>:     push   ebx```

* Change EIP value so when the next instruction is executed, we'll land into mprotect
```bash
gef➤  set $eip=0xf7e8f0d0
gef➤  si```

* At this point we are inside mprotect, we'll keep using `si` until we reach the calling point
```bash
0xf7e8f0e2 <mprotect+0012>  call   DWORD PTR gs:0x10```
*Depending on what you use to compile your program, what appears can be different, so if doesnt look exactly the same, no panic, you see the instruction 'call' then you should be good*

* Next instruction the function will be called, this means all the parameters are already on the stack, in their respective registers, ready to be 'consumed' when the function executes. We know the first param will go into EBX, the second in ECX and the last into EDX.

* The arguments we'll use are:
1. EBX will contain the stack base address as this is the area we wanna apply our changes to: 0xf7e8f0e2
2. ECX will contain the size. In order to find the size we wanna use, lets make few calculations using GDB:
```bash
gef➤ vmmap
... 
0xfffdd000 0xffffe000 0x00000000 rw- [stack]
gef➤  x/x 0xffffe000-0xfffdd000
0x21000:        Cannot access memory at address 0x21000
gef➤  p/u 0x21000
$5 = 135168             # the size of the stack used
gef➤  p/u 0x01010101
$6 = 16843009           # the size we wanna use
gef➤  p/u 0x010101
$7 = 65793              # this size woudl be too small```
*We chose 0x01010101 as our size as this is the biggest size we can use without creating nullbytes characters*
3. EDX will contain 0x7 which is the equivalent of rwx
